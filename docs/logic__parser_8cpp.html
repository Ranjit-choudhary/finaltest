<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: logic_parser.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('logic__parser_8cpp.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">logic_parser.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements functions for parsing, converting, and evaluating propositional logic formulas.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;bits/stdc++.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Node" id="r_Node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brings all identifiers from the std namespace into the global scope.  <a href="struct_node.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6af7d7b17996cc3001b9333be7fb8dd0" id="r_a6af7d7b17996cc3001b9333be7fb8dd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af7d7b17996cc3001b9333be7fb8dd0">isOperator</a> (const string &amp;s)</td></tr>
<tr class="memdesc:a6af7d7b17996cc3001b9333be7fb8dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given string token is a supported logical operator.  <br /></td></tr>
<tr class="memitem:a1904130037b19ead1857ecbc4371d8fa" id="r_a1904130037b19ead1857ecbc4371d8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1904130037b19ead1857ecbc4371d8fa">precedence</a> (const string &amp;op)</td></tr>
<tr class="memdesc:a1904130037b19ead1857ecbc4371d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the precedence level for a logical operator.  <br /></td></tr>
<tr class="memitem:a46478ec9402ac42c88ea28094243d75b" id="r_a46478ec9402ac42c88ea28094243d75b"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46478ec9402ac42c88ea28094243d75b">tokenize</a> (const string &amp;expr)</td></tr>
<tr class="memdesc:a46478ec9402ac42c88ea28094243d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenizes an infix logical expression string into a vector of strings.  <br /></td></tr>
<tr class="memitem:a498bc26ebfcfbaa2c2f7506130525792" id="r_a498bc26ebfcfbaa2c2f7506130525792"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498bc26ebfcfbaa2c2f7506130525792">infixToPrefix</a> (const string &amp;expr)</td></tr>
<tr class="memdesc:a498bc26ebfcfbaa2c2f7506130525792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an infix expression string to a vector of prefix tokens (Polish notation).  <br /></td></tr>
<tr class="memitem:a648691d492ac269bfa7c53775f6b4869" id="r_a648691d492ac269bfa7c53775f6b4869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648691d492ac269bfa7c53775f6b4869">buildParseTree</a> (vector&lt; string &gt; &amp;prefix)</td></tr>
<tr class="memdesc:a648691d492ac269bfa7c53775f6b4869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a parse tree from a vector of prefix tokens.  <br /></td></tr>
<tr class="memitem:a2bf1cb0da72ef303d1462e96c53120d4" id="r_a2bf1cb0da72ef303d1462e96c53120d4"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf1cb0da72ef303d1462e96c53120d4">toInfix</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a2bf1cb0da72ef303d1462e96c53120d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the expression parse tree back to a fully parenthesized infix string (in-order traversal).  <br /></td></tr>
<tr class="memitem:a358cd5a3631aef70e97afac5665f884e" id="r_a358cd5a3631aef70e97afac5665f884e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a358cd5a3631aef70e97afac5665f884e">treeHeight</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a358cd5a3631aef70e97afac5665f884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the height of the expression parse tree.  <br /></td></tr>
<tr class="memitem:a02640c1139f89a3310a3f30967b7ea38" id="r_a02640c1139f89a3310a3f30967b7ea38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02640c1139f89a3310a3f30967b7ea38">evaluate</a> (<a class="el" href="struct_node.html">Node</a> *root, unordered_map&lt; string, bool &gt; &amp;values)</td></tr>
<tr class="memdesc:a02640c1139f89a3310a3f30967b7ea38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively evaluates the truth value of the formula represented by the parse tree based on a given truth assignment for its atoms.  <br /></td></tr>
<tr class="memitem:a2cd3f93488b9be3c314c244fb1ccdad1" id="r_a2cd3f93488b9be3c314c244fb1ccdad1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd3f93488b9be3c314c244fb1ccdad1">dimacsToFormula</a> (const string &amp;filename)</td></tr>
<tr class="memdesc:a2cd3f93488b9be3c314c244fb1ccdad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a formula in DIMACS CNF file format to a standard infix string representation.  <br /></td></tr>
<tr class="memitem:a44ba00063f491516f8c06e89be003202" id="r_a44ba00063f491516f8c06e89be003202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ba00063f491516f8c06e89be003202">collectAtoms</a> (<a class="el" href="struct_node.html">Node</a> *root, set&lt; string &gt; &amp;atoms)</td></tr>
<tr class="memdesc:a44ba00063f491516f8c06e89be003202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the parse tree to collect all unique propositional atoms.  <br /></td></tr>
<tr class="memitem:a7241539255d04f97599e3d5165ecb343" id="r_a7241539255d04f97599e3d5165ecb343"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7241539255d04f97599e3d5165ecb343">evaluateNode</a> (<a class="el" href="struct_node.html">Node</a> *root, const unordered_map&lt; string, bool &gt; &amp;values)</td></tr>
<tr class="memdesc:a7241539255d04f97599e3d5165ecb343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a node given a complete truth assignment.  <br /></td></tr>
<tr class="memitem:a296d154ef98f11a4830f6ed254a6f126" id="r_a296d154ef98f11a4830f6ed254a6f126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a296d154ef98f11a4830f6ed254a6f126">generateTruthTable</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a296d154ef98f11a4830f6ed254a6f126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and prints the full truth table for the formula represented by the parse tree.  <br /></td></tr>
<tr class="memitem:a9c5405cb2613318ab67e1abda2785abc" id="r_a9c5405cb2613318ab67e1abda2785abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5405cb2613318ab67e1abda2785abc">eliminateImplications</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a9c5405cb2613318ab67e1abda2785abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively eliminates implication (&gt;) operators in the parse tree.  <br /></td></tr>
<tr class="memitem:a17e0a979fc7d52e96ee53a20956f71d7" id="r_a17e0a979fc7d52e96ee53a20956f71d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17e0a979fc7d52e96ee53a20956f71d7">moveNegations</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a17e0a979fc7d52e96ee53a20956f71d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively moves negations inward in the parse tree using De Morgan's laws and Double Negation.  <br /></td></tr>
<tr class="memitem:a7b24ae522224d17117bd53dc7ce868b4" id="r_a7b24ae522224d17117bd53dc7ce868b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b24ae522224d17117bd53dc7ce868b4">distributeOrOverAnd</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a7b24ae522224d17117bd53dc7ce868b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively distributes OR over AND to complete the CNF conversion (Distributive Law).  <br /></td></tr>
<tr class="memitem:a07a96650eb6a7afbc72befe067a2c9bd" id="r_a07a96650eb6a7afbc72befe067a2c9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a96650eb6a7afbc72befe067a2c9bd">convertToCNF</a> (<a class="el" href="struct_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a07a96650eb6a7afbc72befe067a2c9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a propositional logic formula's parse tree into Conjunctive Normal Form (CNF).  <br /></td></tr>
<tr class="memitem:acf9d0840e5b90c41e29a7bca69e61ecc" id="r_acf9d0840e5b90c41e29a7bca69e61ecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9d0840e5b90c41e29a7bca69e61ecc">getLiterals</a> (<a class="el" href="struct_node.html">Node</a> *node, vector&lt; string &gt; &amp;literals)</td></tr>
<tr class="memdesc:acf9d0840e5b90c41e29a7bca69e61ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively extracts literals from a clause (an OR-connected subtree).  <br /></td></tr>
<tr class="memitem:a72111bb657980fc4fbbb3bfe27f1d127" id="r_a72111bb657980fc4fbbb3bfe27f1d127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72111bb657980fc4fbbb3bfe27f1d127">collectClauses</a> (<a class="el" href="struct_node.html">Node</a> *cnfRoot, vector&lt; vector&lt; string &gt; &gt; &amp;clauses)</td></tr>
<tr class="memdesc:a72111bb657980fc4fbbb3bfe27f1d127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all clauses from a CNF parse tree.  <br /></td></tr>
<tr class="memitem:abd4645ca85d45066cd4a0405d134067f" id="r_abd4645ca85d45066cd4a0405d134067f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4645ca85d45066cd4a0405d134067f">analyzeCNFValidity</a> (const vector&lt; vector&lt; string &gt; &gt; &amp;clauses, int &amp;valid_count, int &amp;invalid_count)</td></tr>
<tr class="memdesc:abd4645ca85d45066cd4a0405d134067f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the validity (tautology status) of each clause in a CNF formula.  <br /></td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to handle user interaction, execute formula processing tasks, and output results.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements functions for parsing, converting, and evaluating propositional logic formulas. </p>
<p>This file contains definitions for a <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> structure to represent a parse tree, along with functions for infix-to-prefix conversion, parse tree construction, formula evaluation, and Conjunctive Normal Form (CNF) conversion/analysis. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="abd4645ca85d45066cd4a0405d134067f" name="abd4645ca85d45066cd4a0405d134067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4645ca85d45066cd4a0405d134067f">&#9670;&#160;</a></span>analyzeCNFValidity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool analyzeCNFValidity </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clauses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>valid_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>invalid_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes the validity (tautology status) of each clause in a CNF formula. </p>
<p>A clause is a tautology if it contains a literal and its negation (e.g., $A + \neg A$). The overall CNF formula is only a tautology if every single clause is a tautology. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clauses</td><td>The vector of clauses (from <a class="el" href="#a72111bb657980fc4fbbb3bfe27f1d127">collectClauses</a>). </td></tr>
    <tr><td class="paramname">valid_count</td><td>Reference to an integer to store the count of tautological clauses. </td></tr>
    <tr><td class="paramname">invalid_count</td><td>Reference to an integer to store the count of non-tautological clauses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entire CNF formula is a tautology (all clauses are tautological), false otherwise. </dd></dl>

</div>
</div>
<a id="a648691d492ac269bfa7c53775f6b4869" name="a648691d492ac269bfa7c53775f6b4869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648691d492ac269bfa7c53775f6b4869">&#9670;&#160;</a></span>buildParseTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * buildParseTree </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a parse tree from a vector of prefix tokens. </p>
<p>Iterates through the prefix tokens in reverse order, using a stack to assemble the tree structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A reference to the vector of strings in prefix order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the constructed parse tree. </dd></dl>

</div>
</div>
<a id="a44ba00063f491516f8c06e89be003202" name="a44ba00063f491516f8c06e89be003202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ba00063f491516f8c06e89be003202">&#9670;&#160;</a></span>collectAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collectAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atoms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses the parse tree to collect all unique propositional atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the parse tree. </td></tr>
    <tr><td class="paramname">atoms</td><td>A set of strings to store the collected atoms (ensures uniqueness and provides sorted order). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72111bb657980fc4fbbb3bfe27f1d127" name="a72111bb657980fc4fbbb3bfe27f1d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72111bb657980fc4fbbb3bfe27f1d127">&#9670;&#160;</a></span>collectClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collectClauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>cnfRoot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clauses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all clauses from a CNF parse tree. </p>
<p>Clauses are separated by the AND (*) operator. The root of the CNF tree is expected to be an AND-chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnfRoot</td><td>Pointer to the root of the CNF parse tree (expected to be an AND-chain). </td></tr>
    <tr><td class="paramname">clauses</td><td>A vector of vector of strings to store the resulting clauses (each inner vector is a clause/disjunction). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07a96650eb6a7afbc72befe067a2c9bd" name="a07a96650eb6a7afbc72befe067a2c9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a96650eb6a7afbc72befe067a2c9bd">&#9670;&#160;</a></span>convertToCNF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * convertToCNF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a propositional logic formula's parse tree into Conjunctive Normal Form (CNF). </p>
<p>The conversion process involves three main steps:</p><ol type="1">
<li>Eliminate all implications.</li>
<li>Move negations inward to form Negation Normal Form (NNF).</li>
<li>Distribute OR over AND. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the original parse tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the resulting CNF parse tree. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a2cd3f93488b9be3c314c244fb1ccdad1" name="a2cd3f93488b9be3c314c244fb1ccdad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd3f93488b9be3c314c244fb1ccdad1">&#9670;&#160;</a></span>dimacsToFormula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string dimacsToFormula </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a formula in DIMACS CNF file format to a standard infix string representation. </p>
<p>Clauses are represented as disjunctions (+, OR) and clauses are connected by conjunctions (*, AND). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to the DIMACS CNF file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The formula as an infix string, or an empty string if the file fails to open. </dd></dl>

</div>
</div>
<a id="a7b24ae522224d17117bd53dc7ce868b4" name="a7b24ae522224d17117bd53dc7ce868b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b24ae522224d17117bd53dc7ce868b4">&#9670;&#160;</a></span>distributeOrOverAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * distributeOrOverAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively distributes OR over AND to complete the CNF conversion (Distributive Law). </p>
<p>Applies: A + (B * C) -&gt; (A + B) * (A + C). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the current <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> in the parse tree (expected to be in NNF). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root of the final CNF subtree. </dd></dl>

</div>
</div>
<a id="a9c5405cb2613318ab67e1abda2785abc" name="a9c5405cb2613318ab67e1abda2785abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5405cb2613318ab67e1abda2785abc">&#9670;&#160;</a></span>eliminateImplications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * eliminateImplications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively eliminates implication (&gt;) operators in the parse tree. </p>
<p>Applies the transformations: A &gt; B is replaced by ~A + B. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the current <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> in the parse tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root of the modified subtree. </dd></dl>

</div>
</div>
<a id="a02640c1139f89a3310a3f30967b7ea38" name="a02640c1139f89a3310a3f30967b7ea38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02640c1139f89a3310a3f30967b7ea38">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; string, bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively evaluates the truth value of the formula represented by the parse tree based on a given truth assignment for its atoms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the parse tree. </td></tr>
    <tr><td class="paramname">values</td><td>A map of propositional atom names to their boolean truth values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean result of the formula evaluation. </dd></dl>

</div>
</div>
<a id="a7241539255d04f97599e3d5165ecb343" name="a7241539255d04f97599e3d5165ecb343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7241539255d04f97599e3d5165ecb343">&#9670;&#160;</a></span>evaluateNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evaluateNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; string, bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a node given a complete truth assignment. </p>
<p>This is a helper for the truth table generation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> to evaluate. </td></tr>
    <tr><td class="paramname">values</td><td>A constant map of propositional atom names to their boolean truth values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean result of the formula at that node. </dd></dl>

</div>
</div>
<a id="a296d154ef98f11a4830f6ed254a6f126" name="a296d154ef98f11a4830f6ed254a6f126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296d154ef98f11a4830f6ed254a6f126">&#9670;&#160;</a></span>generateTruthTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateTruthTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and prints the full truth table for the formula represented by the parse tree. </p>
<p>Iterates through all $2^n$ possible truth assignments, where $n$ is the number of unique atoms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the parse tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf9d0840e5b90c41e29a7bca69e61ecc" name="acf9d0840e5b90c41e29a7bca69e61ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d0840e5b90c41e29a7bca69e61ecc">&#9670;&#160;</a></span>getLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively extracts literals from a clause (an OR-connected subtree). </p>
<p>A clause is a disjunction of literals. Literals are atoms or negated atoms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the current <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> (should be the root of an OR-chain). </td></tr>
    <tr><td class="paramname">literals</td><td>A vector of strings to store the extracted literals (e.g., "p", "~q"). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a498bc26ebfcfbaa2c2f7506130525792" name="a498bc26ebfcfbaa2c2f7506130525792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498bc26ebfcfbaa2c2f7506130525792">&#9670;&#160;</a></span>infixToPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; infixToPrefix </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an infix expression string to a vector of prefix tokens (Polish notation). </p>
<p>This is achieved by reversing the infix expression, applying a modified Shunting-yard algorithm (as if converting to postfix), and then reversing the result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input infix expression string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings in prefix order. </dd></dl>

</div>
</div>
<a id="a6af7d7b17996cc3001b9333be7fb8dd0" name="a6af7d7b17996cc3001b9333be7fb8dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af7d7b17996cc3001b9333be7fb8dd0">&#9670;&#160;</a></span>isOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isOperator </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given string token is a supported logical operator. </p>
<p>Supported operators: ~ (NOT), * (AND), + (OR), &gt; (IMPLIES). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string token to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the token is an operator, false otherwise. </dd></dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to handle user interaction, execute formula processing tasks, and output results. </p>
<p>Tasks include: Infix to Prefix conversion, Parse Tree construction, Infix output, Tree Height calculation, Manual Evaluation, Truth Table Generation, CNF Conversion, and CNF Validity Check. It can load an expression from user input or a DIMACS file. </p><dl class="section return"><dt>Returns</dt><dd>0 upon successful execution, 1 on error. </dd></dl>

</div>
</div>
<a id="a17e0a979fc7d52e96ee53a20956f71d7" name="a17e0a979fc7d52e96ee53a20956f71d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e0a979fc7d52e96ee53a20956f71d7">&#9670;&#160;</a></span>moveNegations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * moveNegations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively moves negations inward in the parse tree using De Morgan's laws and Double Negation. </p>
<p>Applies: ~~A -&gt; A; ~(A + B) -&gt; ~A * ~B; ~(A * B) -&gt; ~A + ~B. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the current <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> in the parse tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root of the modified subtree (Negation Normal Form - NNF). </dd></dl>

</div>
</div>
<a id="a1904130037b19ead1857ecbc4371d8fa" name="a1904130037b19ead1857ecbc4371d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1904130037b19ead1857ecbc4371d8fa">&#9670;&#160;</a></span>precedence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int precedence </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the precedence level for a logical operator. </p>
<p>Precedence order (highest to lowest): 3: ~ (NOT) 2: * (AND) 1: + (OR) 0: &gt; (IMPLIES) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the precedence level, or -1 if not an operator. </dd></dl>

</div>
</div>
<a id="a2bf1cb0da72ef303d1462e96c53120d4" name="a2bf1cb0da72ef303d1462e96c53120d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf1cb0da72ef303d1462e96c53120d4">&#9670;&#160;</a></span>toInfix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string toInfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the expression parse tree back to a fully parenthesized infix string (in-order traversal). </p>
<p>Uses parentheses for all sub-expressions to ensure correct order of operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the parse tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fully parenthesized infix expression string. </dd></dl>

</div>
</div>
<a id="a46478ec9402ac42c88ea28094243d75b" name="a46478ec9402ac42c88ea28094243d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46478ec9402ac42c88ea28094243d75b">&#9670;&#160;</a></span>tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; tokenize </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenizes an infix logical expression string into a vector of strings. </p>
<p>Handles single-character operators, propositional atoms, and skips whitespace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input infix expression string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings representing the tokens. </dd></dl>

</div>
</div>
<a id="a358cd5a3631aef70e97afac5665f884e" name="a358cd5a3631aef70e97afac5665f884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358cd5a3631aef70e97afac5665f884e">&#9670;&#160;</a></span>treeHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int treeHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the height of the expression parse tree. </p>
<p>The height is the length of the longest path from the root to a leaf node. An empty tree has height 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root <a class="el" href="struct_node.html" title="Brings all identifiers from the std namespace into the global scope.">Node</a> of the parse tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer height of the tree. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="logic__parser_8cpp.html">logic_parser.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
