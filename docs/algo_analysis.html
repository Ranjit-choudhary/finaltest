<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Algorithmic Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style>
    div.contents {
        padding: 1.5rem 2.5rem;
    }

    .contents h1.doxsection {
        color: var(--group-header-color, #90A5CE);
        border-bottom: 1px solid var(--memdef-border-color, #233250);
        margin-top: 2rem;
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
    }
    .contents h2.doxsection {
        color: var(--page-foreground-color, #C9D1D9);
        margin-top: 2rem;
        margin-bottom: 1rem;
    }

    div.contents p, div.contents li {
        font-size: 1.1rem;
        color: var(--page-foreground-color, #C9D1D9);
        line-height: 1.7;
    }
    div.contents ul {
        margin-top: 1rem;
        margin-bottom: 1.5rem;
        list-style: disc;
        padding-left: 2rem;
    }
    div.contents li {
        margin-bottom: 0.5rem;
    }

    span.tt, a.el {
        font-family: var(--font-family-monospace, monospace);
        background-color: var(--memdef-proto-background-color, #19243A);
        border: 1px solid var(--memdef-border-color, #233250);
        border-radius: 4px;
        padding: 0.2em 0.4em;
        font-size: 0.9em;
    }
    a.el {
        color: var(--page-link-color, #90A5CE);
        font-weight: bold;
    }
    a.el:hover {
        text-decoration: underline;
    }

    table.markdownTable {
        border: 1px solid var(--table-cell-border-color, #283A5D);
        border-radius: 8px;
        border-collapse: separate;
        border-spacing: 0;
        margin: 2rem 0;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        overflow: hidden;
    }
    table.markdownTable th {
        background-color: var(--table-header-background-color, #283A5D);
        color: var(--table-header-foreground-color, #C4CFE5);
        font-size: 1.1rem;
        padding: 0.75rem 1rem;
    }
    table.markdownTable td {
        background-color: var(--nav-background-color, #101826);
        padding: 0.75rem 1rem;
        border-top: 1px solid var(--table-cell-border-color, #283A5D);
    }
    table.markdownTable td b {
        color: var(--page-foreground-color, #C9D1D9);
    }

    dl.section.note {
        background: var(--note-color-bg, #3b2e04);
        border-left: 8px solid var(--note-color-hl, #f1b602);
        color: var(--note-color-text, #ceb670);
        padding: 1.5rem 2rem;
        border-radius: 4px;
    }
    dl.section.note dt {
        color: var(--note-color-hl, #f1b602);
        font-weight: bold;
        font-size: 1.1rem;
    }
    dl.section.note dd {
        margin-left: 0;
        font-size: 1.1rem;
        line-height: 1.7;
    }

    hr {
        height: 1px;
        border: none;
        background-color: var(--memdef-border-color, #233250);
        margin: 3rem 0;
    }
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logic in CS Assignment 1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('algo_analysis.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Algorithmic Analysis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A detailed look at algorithm complexity, efficiency, and memory usage.</p>
<h1 class="doxsection"><a class="anchor" id="analysis_intro"></a>
A Detailed Look at Algorithmic Complexity</h1>
<p>A detailed look at your algorithms regarding their output, efficiency (time complexity), and memory usage (space complexity).</p>
<h2 class="doxsection"><a class="anchor" id="analysis_vars"></a>
Variables Used in Analysis</h2>
<ul>
<li><b>n</b>: The number of tokens in the initial infix expression. This measures the input size. </li>
<li><b>N</b>: The number of nodes in the parse tree. <b>N</b> is directly proportional to <b>n</b>, so <b>O(N)</b> is the same as <b>O(n)</b>. </li>
<li><b>h</b>: The height of the parse tree. <ul>
<li>
<b>Best/Average Case (balanced tree):</b> <b>h = O(\log n)</b> </li>
<li>
<b>Worst Case (unbalanced tree, e.g., <span class="tt">a + (b + (c + ...))</span>):</b> <b>h = O(n)</b> </li>
</ul>
</li>
<li><b>k</b>: The number of unique propositional atoms (variables) in the expression (**k \le n**). </li>
<li><b>N_{cnf}</b>: The number of nodes in the <em>final</em> CNF parse tree. This can be much larger than <b>n</b>. </li>
<li><b>C</b>: The number of clauses in the final CNF. </li>
<li><b>L</b>: The maximum number of literals in a single clause in the CNF.</li>
</ul>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="analysis_tasks"></a>
Task-by-Task Complexity Breakdown</h1>
<h2 class="doxsection"><a class="anchor" id="analysis_task1"></a>
Task 1 &amp; 2: Parsing (Infix **\to** Prefix **\to** Tree)</h2>
<p>This includes <span class="tt"><a class="el" href="logic__parser_8cpp.html#a46478ec9402ac42c88ea28094243d75b" title="Tokenizes an infix logical expression string into a vector of strings.">tokenize()</a></span>, <span class="tt"><a class="el" href="logic__parser_8cpp.html#a498bc26ebfcfbaa2c2f7506130525792" title="Converts an infix expression string to a vector of prefix tokens (Polish notation).">infixToPrefix()</a></span>, and <span class="tt"><a class="el" href="logic__parser_8cpp.html#a648691d492ac269bfa7c53775f6b4869" title="Builds a parse tree from a vector of prefix tokens.">buildParseTree()</a></span>.</p>
<ul>
<li><b>Output:</b> The root <span class="tt">Node*</span> of a complete parse tree representing the logic formula. </li>
<li><b>Time</b> <b>Complexity:</b> <b>O(n)</b> <ul>
<li>
<span class="tt"><a class="el" href="logic__parser_8cpp.html#a46478ec9402ac42c88ea28094243d75b" title="Tokenizes an infix logical expression string into a vector of strings.">tokenize()</a></span>: This function scans the input string once. The time is proportional to the number of tokens, <b>O(n)</b>. </li>
<li>
<span class="tt"><a class="el" href="logic__parser_8cpp.html#a498bc26ebfcfbaa2c2f7506130525792" title="Converts an infix expression string to a vector of prefix tokens (Polish notation).">infixToPrefix()</a></span>: This uses a modified Shunting-yard algorithm. Each token is processed, pushed, and popped from the stack at most once. The reverse operations also take <b>O(n)</b>. Total time is <b>O(n)</b>. </li>
<li>
<span class="tt"><a class="el" href="logic__parser_8cpp.html#a648691d492ac269bfa7c53775f6b4869" title="Builds a parse tree from a vector of prefix tokens.">buildParseTree()</a></span>: This processes the prefix tokens in reverse order. Each token involves constant-time stack operations. Total time is <b>O(n)</b>. </li>
</ul>
</li>
<li><b>Space</b> <b>Complexity:</b> <b>O(n)</b> <ul>
<li>
The token list, output list, and operator stack each take up to <b>O(n)</b> space. </li>
<li>
The parse tree creation allocates <b>N</b> nodes proportional to <b>n</b>, and the stack for construction can also reach <b>O(n)</b>. </li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="analysis_task3"></a>
Task 3 &amp; 4: Tree Traversals (Tree **\to** Infix, Height)</h2>
<p>This includes <span class="tt"><a class="el" href="logic__parser_8cpp.html#a2bf1cb0da72ef303d1462e96c53120d4" title="Converts the expression parse tree back to a fully parenthesized infix string (in-order traversal).">toInfix()</a></span>, <span class="tt"><a class="el" href="logic__parser_8cpp.html#a358cd5a3631aef70e97afac5665f884e" title="Computes the height of the expression parse tree.">treeHeight()</a></span>, and <span class="tt"><a class="el" href="logic__parser_8cpp.html#a44ba00063f491516f8c06e89be003202" title="Traverses the parse tree to collect all unique propositional atoms.">collectAtoms()</a></span>.</p>
<ul>
<li><b>Output:</b> A string (<span class="tt">toInfix</span>), an integer (<span class="tt">treeHeight</span>), or a populated set (<span class="tt">collectAtoms</span>). </li>
<li><b>Time</b> <b>Complexity:</b> <b>O(n)</b> <ul>
<li>
These are recursive traversals that visit every node once. </li>
</ul>
</li>
<li><b>Space</b> <b>Complexity:</b> <b>O(h)</b>, which is <b>O(n)</b> in the worst case. <ul>
<li>
Depends on the recursion depth. </li>
<li>
<b>Best Case (balanced tree):</b> <b>O(\log n)</b> </li>
<li>
<b>Worst Case (unbalanced tree):</b> <b>O(n)</b> </li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="analysis_task5"></a>
Task 5: Evaluation (Truth Table)</h2>
<p>This includes <span class="tt"><a class="el" href="logic__parser_8cpp.html#a02640c1139f89a3310a3f30967b7ea38" title="Recursively evaluates the truth value of the formula represented by the parse tree based on a given t...">evaluate()</a></span> and <span class="tt"><a class="el" href="logic__parser_8cpp.html#a296d154ef98f11a4830f6ed254a6f126" title="Generates and prints the full truth table for the formula represented by the parse tree.">generateTruthTable()</a></span>.</p>
<ul>
<li><b>Output:</b> A boolean result (<span class="tt">evaluate</span>) or a printed table (<span class="tt">generateTruthTable</span>).</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#a02640c1139f89a3310a3f30967b7ea38" title="Recursively evaluates the truth value of the formula represented by the parse tree based on a given t...">evaluate()</a></span> (single run)</b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> <b>O(n)</b>. It recursively visits each node once. </li>
<li><b>Space</b> <b>Complexity:</b> <b>O(h)</b>, which is <b>O(n)</b> in the worst case.</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#a296d154ef98f11a4830f6ed254a6f126" title="Generates and prints the full truth table for the formula represented by the parse tree.">generateTruthTable()</a></span> (full analysis)</b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> **O(2^k \cdot n)** <ul>
<li>
It checks all <b>2^k</b> possible truth assignments. </li>
<li>
For each assignment, it calls <span class="tt"><a class="el" href="logic__parser_8cpp.html#a7241539255d04f97599e3d5165ecb343" title="Evaluates a node given a complete truth assignment.">evaluateNode()</a></span> which takes <b>O(n)</b> time. </li>
</ul>
</li>
<li><b>Space</b> <b>Complexity:</b> <b>O(n)</b> <ul>
<li>
The main structures are the atoms list (<b>O(k)</b>), assignment map (<b>O(k)</b>), and recursion stack (<b>O(h)</b>). </li>
<li>
Overall, the space remains <b>O(n)</b> in the worst case. </li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="analysis_task6"></a>
Task 6: CNF Conversion</h2>
<p>This includes <span class="tt"><a class="el" href="logic__parser_8cpp.html#a9c5405cb2613318ab67e1abda2785abc" title="Recursively eliminates implication (&gt;) operators in the parse tree.">eliminateImplications()</a></span>, <span class="tt"><a class="el" href="logic__parser_8cpp.html#a17e0a979fc7d52e96ee53a20956f71d7" title="Recursively moves negations inward in the parse tree using De Morgan&#39;s laws and Double Negation.">moveNegations()</a></span>, and <span class="tt"><a class="el" href="logic__parser_8cpp.html#a7b24ae522224d17117bd53dc7ce868b4" title="Recursively distributes OR over AND to complete the CNF conversion (Distributive Law).">distributeOrOverAnd()</a></span>.</p>
<ul>
<li><b>Output:</b> A new parse tree (or modified one) representing the formula in CNF.</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#a9c5405cb2613318ab67e1abda2785abc" title="Recursively eliminates implication (&gt;) operators in the parse tree.">eliminateImplications()</a></span> and <span class="tt"><a class="el" href="logic__parser_8cpp.html#a17e0a979fc7d52e96ee53a20956f71d7" title="Recursively moves negations inward in the parse tree using De Morgan&#39;s laws and Double Negation.">moveNegations()</a></span></b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> <b>O(n)</b>. Each is a single-pass traversal doing constant work per node. </li>
<li><b>Space</b> <b>Complexity:</b> <b>O(h)</b>, which is <b>O(n)</b> in the worst case.</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#a7b24ae522224d17117bd53dc7ce868b4" title="Recursively distributes OR over AND to complete the CNF conversion (Distributive Law).">distributeOrOverAnd()</a></span></b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> <b>O(2^n)</b> (Exponential) <ul>
<li>
Applying the distributive law can exponentially expand the formula. </li>
<li>
For instance, converting a DNF formula like **(a_1 * b_1) + (a_2 * b_2) + \dots + (a_k * b_k)** to CNF results in about <b>2^k</b> clauses. </li>
</ul>
</li>
<li><b>Space</b> <b>Complexity:</b> <b>O(2^n)</b> <ul>
<li>
The large new parse tree requires exponential memory. </li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="analysis_task7"></a>
Task 7: CNF Validity Check</h2>
<p>This includes <span class="tt"><a class="el" href="logic__parser_8cpp.html#a72111bb657980fc4fbbb3bfe27f1d127" title="Collects all clauses from a CNF parse tree.">collectClauses()</a></span> and <span class="tt"><a class="el" href="logic__parser_8cpp.html#abd4645ca85d45066cd4a0405d134067f" title="Analyzes the validity (tautology status) of each clause in a CNF formula.">analyzeCNFValidity()</a></span>. This analysis focuses on the CNF tree (<b>N_{cnf}</b>, <b>C</b>, <b>L</b>), not the original <b>n</b>.</p>
<ul>
<li><b>Output:</b> A boolean result (<span class="tt">true</span> if the CNF is a tautology).</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#a72111bb657980fc4fbbb3bfe27f1d127" title="Collects all clauses from a CNF parse tree.">collectClauses()</a></span></b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> <b>O(N_{cnf})</b>. Traverses the entire CNF tree. </li>
<li><b>Space</b> <b>Complexity:</b> <b>O(N_{cnf})</b>. Stores all literals in a vector of vectors proportional to <b>N_{cnf}</b>.</li>
</ul>
<p><b><span class="tt"><a class="el" href="logic__parser_8cpp.html#abd4645ca85d45066cd4a0405d134067f" title="Analyzes the validity (tautology status) of each clause in a CNF formula.">analyzeCNFValidity()</a></span></b> </p><ul>
<li><b>Time</b> <b>Complexity:</b> **O(C \cdot L^2)** <ul>
<li>
Iterates through <b>C</b> clauses. </li>
<li>
Each clause has <b>L</b> literals, and checking or inserting each literal in a <span class="tt">std::set</span> can take time proportional to <b>L</b>. </li>
<li>
So, total time is **O(C \cdot L^2)**. </li>
</ul>
</li>
<li><b>Space</b> <b>Complexity:</b> <b>O(L)</b> <ul>
<li>
The main extra memory is the <span class="tt">std::set</span> holding literals in a single clause. </li>
</ul>
</li>
</ul>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="analysis_summary"></a>
Summary of Full Process</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Algorithm  </th><th class="markdownTableHeadLeft">Task  </th><th class="markdownTableHeadLeft">Time Complexity (Worst Case)  </th><th class="markdownTableHeadLeft">Space Complexity (Worst Case)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><span class="tt">infixToPrefix</span>  </td><td class="markdownTableBodyLeft">1  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><span class="tt">buildParseTree</span>  </td><td class="markdownTableBodyLeft">2  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><span class="tt">toInfix</span> / <span class="tt">treeHeight</span>  </td><td class="markdownTableBodyLeft">3, 4  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><span class="tt">generateTruthTable</span>  </td><td class="markdownTableBodyLeft">5  </td><td class="markdownTableBodyLeft">**O(2^k\cdot n)**  </td><td class="markdownTableBodyLeft"><b>O(n)</b>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><span class="tt">convertToCNF</span>  </td><td class="markdownTableBodyLeft">6  </td><td class="markdownTableBodyLeft"><b>O(2^n)</b>  </td><td class="markdownTableBodyLeft"><b>O(2^n)</b>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><span class="tt">analyzeCNFValidity</span>  </td><td class="markdownTableBodyLeft">7  </td><td class="markdownTableBodyLeft">**O(C\cdot L^2)** (on CNF, not <b>n</b>)  </td><td class="markdownTableBodyLeft"><b>O(N_{cnf})</b> (on CNF, not <b>n</b>)  </td></tr>
</table>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="analysis_takeaway"></a>
Key Takeaway</h1>
<p>Our analysis highlights an important concept in computational logic: the cost of canonical forms.</p>
<ul>
<li><b>Truth</b> <b>Table</b> (Task 5): Checking validity using a truth table is exponential in the number of <b>variables</b> (<b>O(2^k)</b>). </li>
<li><b>CNF</b> <b>Conversion</b> (Task 6): Converting a formula to CNF can be exponential in the <b>size</b> of the formula (<b>O(2^n)</b>) because the formula may grow drastically.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This explains why the SAT problem (checking satisfiability) is difficult. Although checking validity on an <em>ready</em> CNF is relatively fast (polynomial in <b>C</b> and <b>L</b>), converting to CNF in the first place is the computationally expensive step. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
